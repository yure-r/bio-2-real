(()=>{"use strict";let t=0;class i{constructor(i,e=0,s=0,o=0,n=0,h=0,a=0){this.id=++t,this.type=i,this.x=e,this.y=s,this.z=o,this.vx=n,this.vy=h,this.vz=a,this.grid=void 0,this.mesh=void 0,this.FLOCK_ENTITY=1,this.OBSTACLE_ENTITY=1}setGrid(t){this.grid=t}getType(){return this.type}getVelocity(){return Math.sqrt(this.vx*this.vx+this.vy*this.vy+this.vz*this.vz)}checkVelocity(t=1){const i=this.getVelocity();i>t&&i>0&&(this.vx=t*this.vx/i,this.vy=t*this.vy/i,this.vz=t*this.vz/i)}addVelocity(t,i,e){this.vx+=t,this.vy+=i,this.vz+=e}move(t,i,e,s){this.checkVelocity(t);let o=this.x+this.vx,n=this.y+this.vy,h=this.z+this.vz;o=Math.max(0,o),o=Math.min(i,o),n=Math.max(0,n),n=Math.min(e,n),h=Math.max(0,h),h=Math.min(s,h),this.grid.moveEntity(this,o,n,h)}getDistance(t){const i=this.x-t.x,e=this.y-t.y,s=this.z-t.z;return Math.sqrt(i*i+e*e+s*s)}serialize(){const{id:t,type:i,x:e,y:s,z:o,vx:n,vy:h,vz:a}=this;return{id:t,type:i,x:e,y:s,z:o,vx:n,vy:h,vz:a}}updateData(t){this.id==t.id&&(this.vx=t.vx,this.vy=t.vy,this.vz=t.vz,this.grid.moveEntity(this,t.x,t.y,t.z))}static deserialize(t){const e=new i(t.type,t.x,t.y,t.z,t.vx,t.vy,t.vz);return e.id=t.id,e}}class e{constructor(t,i){this.worldSize=t,this.cellSize=i,this.cellRowCount=this.worldSize/this.cellSize|0,this.cellCount=this.cellRowCount*this.cellRowCount*this.cellRowCount,this.entityList=[];for(let t=0;t<this.cellCount;t++)this.entityList[t]=[]}getWorldSize(){return this.worldSize}getGridRowCount(){return this.cellRowCount}getGridIndex(t,i,e){let s=t/this.cellSize|0,o=i/this.cellSize|0,n=e/this.cellSize|0;return s<0?s=0:s>this.cellRowCount-1&&(s=this.cellRowCount-1),o<0?o=0:o>this.cellRowCount-1&&(o=this.cellRowCount-1),n<0?n=0:n>this.cellRowCount-1&&(n=this.cellRowCount-1),0|s+o*this.cellRowCount+n*this.cellRowCount*this.cellRowCount}addEntity(t){const i=0|this.getGridIndex(t.x,t.y,t.z);t.setGrid(this),this.entityList[i].push(t)}removeEntity(t){const i=0|this.getGridIndex(t.x,t.y,t.z),e=this.entityList[i],s=e.indexOf(t);if(-1==s)throw"removeEntity() can not find the entity to be removed!";e.splice(s,1),t.setGrid(void 0)}moveEntity(t,i,e,s){const o=0|this.getGridIndex(t.x,t.y,t.z),n=0|this.getGridIndex(i,e,s);if(o==n)return t.x=i,t.y=e,void(t.z=s);const h=this.entityList[o],a=h.indexOf(t);if(-1==a)throw"moveEntity() can not find the entity to be removed!";h.splice(a,1),t.x=i,t.y=e,t.z=s,this.entityList[n].push(t)}getEntitiesInGrid(t,i,e){const s=0|this.getGridIndex(t,i,e);return this.entityList[s]}getEntitiesInGridIndex(t){if(t<0||t>=this.cellCount)throw"getEntitiesInGridIndex() out of bounds!";return this.entityList[0|t]}getEntitiesInCube(t,i,e,s,o){const n=this.getGridIndex(t-s,i-s,e-s),h=this.getGridIndex(t+s,i-s,e-s),a=this.getGridIndex(t-s,i+s,e-s),r=this.getGridIndex(t+s,i+s,e+s),l=n,d=h-n+1,c=(a-n)/this.cellRowCount+1|0,u=(r-n)/(this.cellRowCount*this.cellRowCount)+1|0;for(let n=0;n<u;n++)for(let h=0;h<c;h++)for(let a=0;a<d;a++){const r=l+n*this.cellRowCount*this.cellRowCount+h*this.cellRowCount+a;if(r>=this.cellCount)continue;const d=this.entityList[r],c=d.length;for(let n=0;n<c;n++){const h=d[n];void 0!==h&&h.x>=t-s&&h.x<=t+s&&h.y>=i-s&&h.y<=i+s&&h.z>=e-s&&h.z<=e+s&&o(h)}}}}class s{constructor(t=2e3,i=1e3,s=2e3,o=1){const n=Math.max(t,i,s);this.grid=new e(n,n/o),this.subDivisionCount=o,this.flockEntities=[],this.obstacleEntities=[],this.boundaryX=t,this.boundaryY=i,this.boundaryZ=s,this.aligmentWeight=3,this.cohesionWeight=3.4,this.separationWeight=.3,this.maxEntitySpeed=.5,this.aligmentRadius=30,this.cohesionRadius=30,this.separationRadius=30,this.obstacleRadius=30}addFlockEntity(t){this.grid.addEntity(t),this.flockEntities.push(t)}getFlockEntities(){return this.flockEntities}addObstacleEntity(t){this.grid.addEntity(t),this.obstacleEntities.push(t)}getObstacleEntities(){return this.obstacleEntities}getBoundary(){return[this.boundaryX,this.boundaryY,this.boundaryZ]}setMaxSpeed(t){this.maxEntitySpeed=t}setAligmentWeight(t){this.aligmentWeight=t}setCohesionWeight(t){this.cohesionWeight=t}setSeparationWeight(t){this.separationWeight=t}setBoundary(t,i,e){this.boundaryX=t,this.boundaryY=i,this.boundaryZ=e}iterate(t=0,i=this.flockEntities.length){for(let e=t;e<i;e++){const t=this.flockEntities[e],i=this.computeAlignment(t),s=this.computeCohesion(t),o=this.computeSeparation(t),n=this.computeObstacles(t),h=this.aligmentWeight*i[0]+this.cohesionWeight*s[0]+50*this.separationWeight*o[0]+100*n[0],a=this.aligmentWeight*i[1]+this.cohesionWeight*s[1]+50*this.separationWeight*o[1]+100*n[1],r=this.aligmentWeight*i[2]+this.cohesionWeight*s[2]+50*this.separationWeight*o[2]+100*n[2];t.addVelocity(h,a,r),t.move(this.maxEntitySpeed,this.boundaryX,this.boundaryY,this.boundaryZ)}}computeAlignment(t){let e=0,s=0,o=0,n=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.aligmentRadius,(h=>{h!=t&&h.getType()==i.FLOCK_ENTITY&&t.getDistance(h)<this.aligmentRadius&&(n++,e+=h.vx,s+=h.vy,o+=h.vz)})),n>0){e/=n,s/=n,o/=n;const t=Math.sqrt(e*e+s*s+o*o);t>0&&(e/=t,s/=t,o/=t)}return[e,s,o]}computeCohesion(t){let e=0,s=0,o=0,n=0;if(this.grid.getEntitiesInCube(t.x,t.y,t.z,this.cohesionRadius,(h=>{h!=t&&h.getType()==i.FLOCK_ENTITY&&t.getDistance(h)<this.cohesionRadius&&(n++,e+=h.x,s+=h.y,o+=h.z)})),n>0){e/=n,s/=n,o/=n,e-=t.x,s-=t.y,o-=t.z;var h=Math.sqrt(e*e+s*s+o*o);h>0&&(e/=h,s/=h,o/=h)}return[e,s,o]}computeSeparation(t){let e=0,s=0,o=0;return this.grid.getEntitiesInCube(t.x,t.y,t.z,this.separationRadius,(n=>{let h=t.getDistance(n);if(h<=0&&(h=.01),n!=t&&n.getType()==i.FLOCK_ENTITY&&h<this.separationRadius){const i=t.x-n.x,a=t.y-n.y,r=t.z-n.z;e+=i/h/h,s+=a/h/h,o+=r/h/h}})),[e,s,o]}computeObstacles(t){let e=0,s=0,o=0;this.grid.getEntitiesInCube(t.x,t.y,t.z,this.obstacleRadius,(n=>{const h=t.getDistance(n);if(h>0&&n.getType()==i.OBSTACLE_ENTITY&&h<this.obstacleRadius){const i=t.x-n.x,a=t.y-n.y,r=t.z-n.z;e+=i/h/h,s+=a/h/h,o+=r/h/h}}));const n=this.obstacleRadius/4,h=this.boundaryX-t.x,a=this.boundaryY-t.y,r=this.boundaryZ-t.z;return t.x<n&&Math.abs(t.x)>0?e+=1/t.x:h<n&&h>0&&(e-=1/h),t.y<n&&Math.abs(t.y)>0?s+=1/t.y:a<n&&a>0&&(s-=1/a),t.z<n&&Math.abs(t.z)>0?o+=1/t.z:r<n&&r>0&&(o-=1/r),[e,s,o]}serialize(){const t=[],i=[];return this.flockEntities.forEach((i=>{t.push(i.serialize())})),this.obstacleEntities.forEach((t=>{i.push(t.serialize())})),{subDivisionCount:this.subDivisionCount,boundaryX:this.boundaryX,boundaryY:this.boundaryY,boundaryZ:this.boundaryZ,flockEntities:t,obstacleEntities:i,aligmentWeight:this.aligmentWeight,cohesionWeight:this.cohesionWeight,separationWeight:this.separationWeight,maxEntitySpeed:this.maxEntitySpeed,aligmentRadius:this.aligmentRadius,cohesionRadius:this.cohesionRadius,separationRadius:this.separationRadius,obstacleRadius:this.obstacleRadius}}serializeBoidsData(t=0,i=this.flockEntities.length){const e=[];for(let s=t;s<i;s++)e.push(this.flockEntities[s].serialize());return{start:t,flockEntities:e}}applyBoidsData(t){const i=t.start,e=t.flockEntities;for(let t=0;t<e.length;t++){const s=this.flockEntities[i+t],o=e[t];s.id==o.id?s.updateData(o):console.log("ids do not match!")}}static deserialize(t){const e=new s(t.boundaryX,t.boundaryY,t.boundaryZ,t.subDivisionCount);return e.aligmentWeight=t.aligmentWeight,e.cohesionWeight=t.cohesionWeight,e.separationWeight=t.separationWeight,e.maxEntitySpeed=t.maxEntitySpeed,e.aligmentRadius=t.aligmentRadius,e.cohesionRadius=t.cohesionRadius,e.separationRadius=t.separationRadius,e.obstacleRadius=t.obstacleRadius,t.flockEntities.forEach((t=>{const s=i.deserialize(t);e.addFlockEntity(s)})),t.obstacleEntities.forEach((t=>{const s=i.deserialize(t);e.addObstacleEntity(s)})),e}}const o=new class{constructor(){this.boidsController=void 0}initializeBoidsController(t){this.boidsController=s.deserialize(t)}iterateBoidsController(t,i,e){this.boidsController.aligmentWeight=e.aligmentWeight,this.boidsController.cohesionWeight=e.cohesionWeight,this.boidsController.separationWeight=e.separationWeight,this.boidsController.maxEntitySpeed=e.maxEntitySpeed,this.boidsController.iterate(t,i);const s=this.boidsController.serializeBoidsData(t,i);postMessage({action:"iterateCompleted",data:s})}updateBoidsData(t){this.boidsController.applyBoidsData(t)}onMessage(t){"initialData"==t.data.action?this.initializeBoidsController(t.data.data):"iterate"==t.data.action?this.iterateBoidsController(t.data.start,t.data.end,t.data.config):(t.data.action="updateBoidsData")&&this.updateBoidsData(t.data.data)}};onmessage=o.onMessage.bind(o)})();